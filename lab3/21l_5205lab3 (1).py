# -*- coding: utf-8 -*-
"""21l-5205lab3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/162OwWXtIGV0wJ-o9QQK6mIPZArqMS6kw
"""

import heapq


def read_map(filename):
    with open(filename, 'r') as file:
        return [list(line.strip()) for line in file]

def get_neighbors(grid, r, c):
    neighbors = []
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    for dr, dc in directions:
        nr, nc = r + dr, c + dc
        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != '1':
            neighbors.append((nr, nc))
    return neighbors

# calculating heuristic for A* algorithm
def heuristic(start, goal):
    return abs(start[0] - goal[0]) + abs(start[1] - goal[1])

# DFS Algorithm
def dfs(grid, start, goal):
    visited = set()
    stack = [(start, [])]

    while stack:
        current, path = stack.pop()
        if current == goal:
            return path + [current]
        if current not in visited:
            visited.add(current)
            for neighbor in get_neighbors(grid, *current):
                stack.append((neighbor, path + [current]))

    print("Oh, no. Anato is doomed and going to die in suspense without watching the Final episode.")
    return -1

# BFS Algorithm
def bfs(grid, start, goal):
    visited = set()
    queue = [(start, [])]

    while queue:
        current, path = queue.pop(0)
        if current == goal:
            return path + [current]
        if current not in visited:
            visited.add(current)
            for neighbor in get_neighbors(grid, *current):
                queue.append((neighbor, path + [current]))

    print("Oh, no. Anato is doomed and going to die in suspense without watching the Final episode.")
    return -1

# UCS Algorithm
def ucs(grid, start, goal):
    visited = set()
    pq = [(0, start, [])]

    while pq:
        cost, current, path = heapq.heappop(pq)
        if current == goal:
            return path + [current]
        if current not in visited:
            visited.add(current)
            for neighbor in get_neighbors(grid, *current):
                heapq.heappush(pq, (cost + 1, neighbor, path + [current]))

    print("Oh, no. Anato is doomed and going to die in suspense without watching the Final episode.")
    return -1

# A* Algorithm
def astar(grid, start, goal):
    visited = set()
    pq = [(0, start, [])]

    while pq:
        _, current, path = heapq.heappop(pq)
        if current == goal:
            return path + [current]
        if current not in visited:
            visited.add(current)
            for neighbor in get_neighbors(grid, *current):
                g_cost = len(path) + 1
                h_cost = heuristic(neighbor, goal)
                f_cost = g_cost + h_cost
                heapq.heappush(pq, (f_cost, neighbor, path + [current]))

    print("Oh, no. Anato is doomed and going to die in suspense without watching the Final episode.")
    return -1

# example main func:
map_grid = read_map("map.txt")
start_position = (0, 0)  # Example start position
goal_position = (4, 4)   # Example goal position

print("DFS Path:", dfs(map_grid, start_position, goal_position))
print("BFS Path:", bfs(map_grid, start_position, goal_position))
print("UCS Path:", ucs(map_grid, start_position, goal_position))
print("A* Path:", astar(map_grid, start_position, goal_position))